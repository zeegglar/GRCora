import jsPDF from 'jspdf';
import { GoogleGenerativeAI } from '@google/generative-ai';
import type { Project, AssessmentItem, Risk, Control, Organization } from '../types';
import { supabaseApi } from './supabaseApi';

// Initialize Gemini AI
const genai = new GoogleGenerativeAI(import.meta.env.VITE_GOOGLE_API_KEY || '');

export interface ReportData {
  project: Project;
  organization: Organization;
  assessmentItems: AssessmentItem[];
  risks: Risk[];
  controls: Control[];
  reportType: 'assessment' | 'executive_summary' | 'risk_register' | 'compliance';
}

export class ReportGenerator {
  private static addHeader(doc: jsPDF, organization: Organization, reportTitle: string) {
    // Add organization logo space (if available)
    doc.setFontSize(20);
    doc.setTextColor(25, 30, 50);
    doc.text(organization.name, 20, 25);

    // Report title
    doc.setFontSize(16);
    doc.setTextColor(100, 100, 100);
    doc.text(reportTitle, 20, 35);

    // Date
    doc.setFontSize(10);
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 45);

    // Line separator
    doc.setDrawColor(200, 200, 200);
    doc.line(20, 50, 190, 50);
  }

  private static addFooter(doc: jsPDF, pageNumber: number) {
    const pageHeight = doc.internal.pageSize.height;
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text(`Page ${pageNumber}`, 20, pageHeight - 10);
    doc.text('Generated by GRCora - Confidential', 150, pageHeight - 10);
  }

  private static async generateExecutiveSummary(data: ReportData): Promise<string> {
    try {
      const model = genai.getGenerativeModel({ model: 'gemini-pro' });

      const criticalRisks = data.risks.filter(r => r.level === 'CRITICAL').length;
      const highRisks = data.risks.filter(r => r.level === 'HIGH').length;
      const compliantItems = data.assessmentItems.filter(a => a.status === 'Compliant').length;
      const totalItems = data.assessmentItems.length;
      const complianceRate = totalItems > 0 ? Math.round((compliantItems / totalItems) * 100) : 0;

      const prompt = `
        Generate a professional executive summary for a GRC assessment report with the following data:

        Organization: ${data.organization.name}
        Project: ${data.project.name}
        Frameworks: ${data.project.frameworks.join(', ')}

        Assessment Results:
        - Total Controls Assessed: ${totalItems}
        - Compliant Controls: ${compliantItems}
        - Compliance Rate: ${complianceRate}%
        - Critical Risks: ${criticalRisks}
        - High Risks: ${highRisks}
        - Total Open Risks: ${data.risks.filter(r => r.status === 'Open').length}

        Please provide:
        1. A brief executive overview (2-3 sentences)
        2. Key findings and risk highlights
        3. Compliance status summary
        4. Priority recommendations (3-4 items)

        Keep it professional, concise, and actionable for executives. Format as plain text with clear sections.
      `;

      const result = await model.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error('Error generating AI summary:', error);
      return `Executive Summary for ${data.organization.name} - ${data.project.name}

Assessment Overview:
This report presents the findings from our ${data.project.frameworks.join(', ')} assessment conducted for ${data.organization.name}.

Key Findings:
• Compliance Rate: ${Math.round((data.assessmentItems.filter(a => a.status === 'Compliant').length / data.assessmentItems.length) * 100)}%
• Critical Risks Identified: ${data.risks.filter(r => r.level === 'CRITICAL').length}
• High Priority Risks: ${data.risks.filter(r => r.level === 'HIGH').length}

Recommendations:
1. Address critical risks immediately
2. Implement missing controls for non-compliant items
3. Establish ongoing monitoring procedures
4. Schedule regular risk assessments`;
    }
  }

  private static async generateRiskAnalysis(risks: Risk[]): Promise<string> {
    try {
      const model = genai.getGenerativeModel({ model: 'gemini-pro' });

      const riskSummary = risks.map(r =>
        `${r.title} (${r.level}) - ${r.status}`
      ).join('\n');

      const prompt = `
        Analyze these cybersecurity risks and provide professional insights:

        ${riskSummary}

        Please provide:
        1. Risk trend analysis
        2. Common risk patterns identified
        3. Business impact assessment
        4. Recommended mitigation strategies

        Keep it professional and actionable for security teams.
      `;

      const result = await model.generateContent(prompt);
      return result.response.text();
    } catch (error) {
      console.error('Error generating risk analysis:', error);
      return 'Risk analysis temporarily unavailable. Please review individual risk items below.';
    }
  }

  static async generateAssessmentReport(data: ReportData): Promise<Blob> {
    const doc = new jsPDF();
    let yPosition = 60;

    // Header
    this.addHeader(doc, data.organization, `${data.project.frameworks.join('/')} Assessment Report`);

    // Executive Summary
    yPosition += 10;
    doc.setFontSize(14);
    doc.setTextColor(25, 30, 50);
    doc.text('Executive Summary', 20, yPosition);

    yPosition += 10;
    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);

    const executiveSummary = await this.generateExecutiveSummary(data);
    const summaryLines = doc.splitTextToSize(executiveSummary, 170);
    doc.text(summaryLines, 20, yPosition);
    yPosition += summaryLines.length * 5 + 10;

    // Assessment Overview
    if (yPosition > 250) {
      doc.addPage();
      yPosition = 30;
    }

    doc.setFontSize(14);
    doc.setTextColor(25, 30, 50);
    doc.text('Assessment Overview', 20, yPosition);
    yPosition += 15;

    // Compliance Statistics
    const compliantItems = data.assessmentItems.filter(a => a.status === 'Compliant').length;
    const nonCompliantItems = data.assessmentItems.filter(a => a.status === 'Non-Compliant').length;
    const inProgressItems = data.assessmentItems.filter(a => a.status === 'In Progress').length;
    const criticalItems = data.assessmentItems.filter(a => a.status === 'Critical').length;

    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);

    const stats = [
      `Total Controls Assessed: ${data.assessmentItems.length}`,
      `Compliant: ${compliantItems} (${Math.round((compliantItems / data.assessmentItems.length) * 100)}%)`,
      `Non-Compliant: ${nonCompliantItems}`,
      `In Progress: ${inProgressItems}`,
      `Critical Issues: ${criticalItems}`
    ];

    stats.forEach(stat => {
      doc.text(stat, 20, yPosition);
      yPosition += 7;
    });

    // Risk Summary
    yPosition += 10;
    doc.setFontSize(14);
    doc.setTextColor(25, 30, 50);
    doc.text('Risk Summary', 20, yPosition);
    yPosition += 15;

    const criticalRisks = data.risks.filter(r => r.level === 'CRITICAL').length;
    const highRisks = data.risks.filter(r => r.level === 'HIGH').length;
    const mediumRisks = data.risks.filter(r => r.level === 'MEDIUM').length;
    const lowRisks = data.risks.filter(r => r.level === 'LOW').length;

    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);

    const riskStats = [
      `Total Risks Identified: ${data.risks.length}`,
      `Critical: ${criticalRisks}`,
      `High: ${highRisks}`,
      `Medium: ${mediumRisks}`,
      `Low: ${lowRisks}`
    ];

    riskStats.forEach(stat => {
      doc.text(stat, 20, yPosition);
      yPosition += 7;
    });

    // Add new page for detailed findings
    doc.addPage();
    yPosition = 30;

    // Control Assessment Details
    doc.setFontSize(14);
    doc.setTextColor(25, 30, 50);
    doc.text('Control Assessment Details', 20, yPosition);
    yPosition += 15;

    doc.setFontSize(8);

    // Table headers
    doc.setTextColor(255, 255, 255);
    doc.setFillColor(70, 70, 70);
    doc.rect(20, yPosition, 170, 8, 'F');
    doc.text('Control ID', 22, yPosition + 5);
    doc.text('Control Name', 50, yPosition + 5);
    doc.text('Status', 120, yPosition + 5);
    doc.text('Framework', 150, yPosition + 5);
    yPosition += 8;

    // Assessment items
    doc.setTextColor(80, 80, 80);
    data.assessmentItems.forEach((item, index) => {
      if (yPosition > 280) {
        doc.addPage();
        yPosition = 30;

        // Repeat headers
        doc.setTextColor(255, 255, 255);
        doc.setFillColor(70, 70, 70);
        doc.rect(20, yPosition, 170, 8, 'F');
        doc.text('Control ID', 22, yPosition + 5);
        doc.text('Control Name', 50, yPosition + 5);
        doc.text('Status', 120, yPosition + 5);
        doc.text('Framework', 150, yPosition + 5);
        yPosition += 8;
        doc.setTextColor(80, 80, 80);
      }

      const control = data.controls.find(c => c.id === item.controlId);

      // Alternate row colors
      if (index % 2 === 0) {
        doc.setFillColor(250, 250, 250);
        doc.rect(20, yPosition, 170, 6, 'F');
      }

      doc.text(item.controlId || '', 22, yPosition + 4);
      doc.text(doc.splitTextToSize(control?.name || '', 65)[0] || '', 50, yPosition + 4);

      // Color code status
      switch (item.status) {
        case 'Compliant':
          doc.setTextColor(0, 150, 0);
          break;
        case 'Non-Compliant':
          doc.setTextColor(200, 0, 0);
          break;
        case 'Critical':
          doc.setTextColor(150, 0, 0);
          break;
        default:
          doc.setTextColor(200, 150, 0);
      }

      doc.text(item.status, 120, yPosition + 4);
      doc.setTextColor(80, 80, 80);
      doc.text(control?.framework || '', 150, yPosition + 4);

      yPosition += 6;
    });

    // Add footer to all pages
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      this.addFooter(doc, i);
    }

    return doc.output('blob');
  }

  static async generateExecutiveDashboard(data: ReportData): Promise<Blob> {
    const doc = new jsPDF();

    // Header
    this.addHeader(doc, data.organization, 'Executive Dashboard');

    let yPosition = 70;

    // Key Metrics Cards
    doc.setFontSize(16);
    doc.setTextColor(25, 30, 50);
    doc.text('Key Performance Indicators', 20, yPosition);
    yPosition += 20;

    const compliantItems = data.assessmentItems.filter(a => a.status === 'Compliant').length;
    const complianceRate = Math.round((compliantItems / data.assessmentItems.length) * 100);
    const criticalRisks = data.risks.filter(r => r.level === 'CRITICAL').length;
    const highRisks = data.risks.filter(r => r.level === 'HIGH').length;

    // Compliance Rate Box
    doc.setFillColor(0, 150, 0);
    if (complianceRate < 70) doc.setFillColor(200, 0, 0);
    else if (complianceRate < 85) doc.setFillColor(255, 165, 0);

    doc.rect(20, yPosition, 40, 30, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.text(`${complianceRate}%`, 25, yPosition + 15);
    doc.setFontSize(10);
    doc.text('Compliance Rate', 22, yPosition + 25);

    // Critical Risks Box
    doc.setFillColor(criticalRisks > 0 ? 200 : 0, criticalRisks > 0 ? 0 : 150, 0);
    doc.rect(70, yPosition, 40, 30, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.text(`${criticalRisks}`, 85, yPosition + 15);
    doc.setFontSize(10);
    doc.text('Critical Risks', 72, yPosition + 25);

    // High Risks Box
    doc.setFillColor(highRisks > 3 ? 255 : 0, highRisks > 3 ? 165 : 150, 0);
    doc.rect(120, yPosition, 40, 30, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.text(`${highRisks}`, 135, yPosition + 15);
    doc.setFontSize(10);
    doc.text('High Risks', 122, yPosition + 25);

    yPosition += 50;

    // AI-Generated Executive Summary
    doc.setFontSize(14);
    doc.setTextColor(25, 30, 50);
    doc.text('Executive Summary', 20, yPosition);
    yPosition += 15;

    const aiSummary = await this.generateExecutiveSummary(data);
    doc.setFontSize(10);
    doc.setTextColor(80, 80, 80);
    const summaryLines = doc.splitTextToSize(aiSummary, 170);
    doc.text(summaryLines, 20, yPosition);

    this.addFooter(doc, 1);
    return doc.output('blob');
  }

  static async generateRiskRegister(data: ReportData): Promise<Blob> {
    const doc = new jsPDF();

    // Header
    this.addHeader(doc, data.organization, 'Risk Register');

    let yPosition = 70;

    // AI Risk Analysis
    const riskAnalysis = await this.generateRiskAnalysis(data.risks);
    doc.setFontSize(12);
    doc.setTextColor(25, 30, 50);
    doc.text('Risk Analysis', 20, yPosition);
    yPosition += 15;

    doc.setFontSize(9);
    doc.setTextColor(80, 80, 80);
    const analysisLines = doc.splitTextToSize(riskAnalysis, 170);
    doc.text(analysisLines, 20, yPosition);
    yPosition += analysisLines.length * 4 + 15;

    // Risk Table
    doc.setFontSize(12);
    doc.setTextColor(25, 30, 50);
    doc.text('Risk Details', 20, yPosition);
    yPosition += 15;

    // Table headers
    doc.setFontSize(8);
    doc.setTextColor(255, 255, 255);
    doc.setFillColor(70, 70, 70);
    doc.rect(20, yPosition, 170, 8, 'F');
    doc.text('Risk Title', 22, yPosition + 5);
    doc.text('Level', 90, yPosition + 5);
    doc.text('Status', 120, yPosition + 5);
    doc.text('Owner', 150, yPosition + 5);
    yPosition += 8;

    // Risk rows
    doc.setTextColor(80, 80, 80);
    data.risks.forEach((risk, index) => {
      if (yPosition > 280) {
        doc.addPage();
        yPosition = 30;
      }

      // Alternate row colors
      if (index % 2 === 0) {
        doc.setFillColor(250, 250, 250);
        doc.rect(20, yPosition, 170, 10, 'F');
      }

      doc.text(doc.splitTextToSize(risk.title, 65)[0], 22, yPosition + 4);

      // Color code risk level
      switch (risk.level) {
        case 'CRITICAL':
          doc.setTextColor(150, 0, 0);
          break;
        case 'HIGH':
          doc.setTextColor(200, 0, 0);
          break;
        case 'MEDIUM':
          doc.setTextColor(255, 165, 0);
          break;
        default:
          doc.setTextColor(0, 150, 0);
      }

      doc.text(risk.level, 90, yPosition + 4);
      doc.setTextColor(80, 80, 80);
      doc.text(risk.status, 120, yPosition + 4);
      doc.text(risk.owner || 'Unassigned', 150, yPosition + 4);

      yPosition += 10;
    });

    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      this.addFooter(doc, i);
    }

    return doc.output('blob');
  }

  static async generateAndSaveReport(data: ReportData): Promise<string> {
    let pdfBlob: Blob;
    let reportTitle: string;

    switch (data.reportType) {
      case 'assessment':
        pdfBlob = await this.generateAssessmentReport(data);
        reportTitle = `${data.project.frameworks.join('/')} Assessment Report`;
        break;
      case 'executive_summary':
        pdfBlob = await this.generateExecutiveDashboard(data);
        reportTitle = 'Executive Dashboard Summary';
        break;
      case 'risk_register':
        pdfBlob = await this.generateRiskRegister(data);
        reportTitle = 'Risk Register';
        break;
      default:
        throw new Error('Unsupported report type');
    }

    // Save to Supabase and return download URL
    return await supabaseApi.createReport(reportTitle, data.reportType, data.project.id, pdfBlob);
  }
}